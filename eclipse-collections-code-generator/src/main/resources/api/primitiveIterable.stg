import "copyright.stg"
import "primitiveLiteral.stg"

targetPath() ::= "org/eclipse/collections/api"

fileName(primitive) ::= "<primitive.name>Iterable"

class(primitive) ::= <<
<body(primitive.type, primitive.name)>
>>

body(type, name) ::= <<
<copyright()>

package org.eclipse.collections.api;

import java.util.Collection;
<(wideStatisticsImport.(type))>

import org.eclipse.collections.api.bag.primitive.Mutable<name>Bag;
import org.eclipse.collections.api.block.function.primitive.<name>ToBooleanFunction;
import org.eclipse.collections.api.block.function.primitive.<name>ToByteFunction;
import org.eclipse.collections.api.block.function.primitive.<name>ToShortFunction;
import org.eclipse.collections.api.block.function.primitive.<name>ToCharFunction;
import org.eclipse.collections.api.block.function.primitive.<name>ToDoubleFunction;
import org.eclipse.collections.api.block.function.primitive.<name>ToFloatFunction;
import org.eclipse.collections.api.block.function.primitive.<name>ToIntFunction;
import org.eclipse.collections.api.block.function.primitive.<name>ToLongFunction;
import org.eclipse.collections.api.block.function.primitive.Object<name>ToObjectFunction;
import org.eclipse.collections.api.block.function.primitive.<name>ToObjectFunction;
import org.eclipse.collections.api.block.predicate.primitive.<name>Predicate;
import org.eclipse.collections.api.block.procedure.primitive.<name>Procedure;
import org.eclipse.collections.api.collection.primitive.MutableBooleanCollection;
import org.eclipse.collections.api.collection.primitive.MutableByteCollection;
import org.eclipse.collections.api.collection.primitive.MutableCharCollection;
import org.eclipse.collections.api.collection.primitive.MutableDoubleCollection;
import org.eclipse.collections.api.collection.primitive.MutableFloatCollection;
import org.eclipse.collections.api.collection.primitive.MutableIntCollection;
import org.eclipse.collections.api.collection.primitive.MutableLongCollection;
import org.eclipse.collections.api.collection.primitive.MutableShortCollection;
import org.eclipse.collections.api.iterator.<name>Iterator;
import org.eclipse.collections.api.list.primitive.Mutable<name>List;
import org.eclipse.collections.api.set.primitive.Mutable<name>Set;

/**
 * <name>Iterable is an interface which is memory-optimized for <type> primitives.
 * It is inspired by the interface RichIterable, and contains a subset of the internal iterator methods on RichIterable like collect, sum, etc.
 * The API also includes an external iterator method, which returns an <name>Iterator. <name>Iterator helps iterate over the <name>Iterable without boxing the primitives.
 * This file was automatically generated from template file primitiveIterable.stg.
 */
public interface <name>Iterable extends PrimitiveIterable
{
    <name>Iterator <type>Iterator();

    <type>[] toArray();

    boolean contains(<type> value);

    boolean containsAll(<type>... source);

    boolean containsAll(<name>Iterable source);

    void forEach(<name>Procedure procedure);

    /**
     * @since 7.0.
     */
    void each(<name>Procedure procedure);

    <name>Iterable select(<name>Predicate predicate);

    <name>Iterable reject(<name>Predicate predicate);

    \<V> RichIterable\<V> collect(<name>ToObjectFunction\<? extends V> function);

    /**
     * @since 8.1.
     */
    default \<V, R extends Collection\<V>\> R collect(<name>ToObjectFunction\<? extends V> function, R target)
    {
        this.each(each -> target.add(function.valueOf(each)));
        return target;
    }

    /**
     * @since 8.1.
     */
    default \<V, R extends Collection\<V>\> R flatCollect(<name>ToObjectFunction\<? extends Iterable\<V>\> function, R target)
    {
        this.each(each ->
        {
            Iterable\<V> iterable = function.valueOf(each);
            if (iterable instanceof Collection)
            {
                target.addAll((Collection\<V>) iterable);
            }
            else
            {
                iterable.forEach(target::add);
            }
        });
        return target;
    }

    /**
     * @since 8.1.
     */
    default \<R extends MutableBooleanCollection> R collectBoolean(<name>ToBooleanFunction function, R target)
    {
        this.each(each ->  target.add(function.valueOf(each)));
        return target;
    }

    /**
     * @since 8.1.
     */
    default \<R extends MutableByteCollection> R collectByte(<name>ToByteFunction function, R target)
    {
        this.each(each ->  target.add(function.valueOf(each)));
        return target;
    }

    /**
     * @since 8.1.
     */
    default \<R extends MutableCharCollection> R collectChar(<name>ToCharFunction function, R target)
    {
        this.each(each ->  target.add(function.valueOf(each)));
        return target;
    }

    /**
     * @since 8.1.
     */
    default \<R extends MutableShortCollection> R collectShort(<name>ToShortFunction function, R target)
    {
        this.each(each ->  target.add(function.valueOf(each)));
        return target;
    }

    /**
     * @since 8.1.
     */
    default \<R extends MutableIntCollection> R collectInt(<name>ToIntFunction function, R target)
    {
        this.each(each ->  target.add(function.valueOf(each)));
        return target;
    }

    /**
     * @since 8.1.
     */
    default \<R extends MutableFloatCollection> R collectFloat(<name>ToFloatFunction function, R target)
    {
        this.each(each ->  target.add(function.valueOf(each)));
        return target;
    }

    /**
     * @since 8.1.
     */
    default \<R extends MutableLongCollection> R collectLong(<name>ToLongFunction function, R target)
    {
        this.each(each ->  target.add(function.valueOf(each)));
        return target;
    }

    /**
     * @since 8.1.
     */
    default \<R extends MutableDoubleCollection> R collectDouble(<name>ToDoubleFunction function, R target)
    {
        this.each(each ->  target.add(function.valueOf(each)));
        return target;
    }

    <type> detectIfNone(<name>Predicate predicate, <type> ifNone);

    int count(<name>Predicate predicate);

    boolean anySatisfy(<name>Predicate predicate);

    boolean allSatisfy(<name>Predicate predicate);

    boolean noneSatisfy(<name>Predicate predicate);

    Mutable<name>List toList();

    Mutable<name>Set toSet();

    Mutable<name>Bag toBag();

    Lazy<name>Iterable asLazy();

    \<T> T injectInto(T injectedValue, Object<name>ToObjectFunction\<? super T, ? extends T> function);
    <(arithmeticMethods.(type))()>
}

>>

arithmeticMethods ::= [
    "byte": "allMethods",
    "short": "allMethods",
    "char": "allMethods",
    "int": "allMethods",
    "long": "allMethods",
    "float": "allMethods",
    "double": "allMethods",
    "boolean": "noMethods"
    ]

allMethods() ::= <<
<\n>
<(wideType.(type))> sum();

/**
 * @since 8.0
 */
default <(wideStatistics.(type))> summaryStatistics()
{
    <(wideStatistics.(type))> stats = new <(wideStatistics.(type))>();
    this.forEach(stats::accept);
    return stats;
}

<type> max();

<type> maxIfEmpty(<type> defaultValue);

<type> min();

<type> minIfEmpty(<type> defaultValue);

double average();

double median();

<type>[] toSortedArray();

Mutable<name>List toSortedList();
>>

noMethods() ::= ""

wideStatistics ::= [
    "byte": "IntSummaryStatistics",
    "short": "IntSummaryStatistics",
    "char": "IntSummaryStatistics",
    "int": "IntSummaryStatistics",
    "long": "LongSummaryStatistics",
    "float": "DoubleSummaryStatistics",
    "double": "DoubleSummaryStatistics",
    default: "no matching wide type"
]

wideStatisticsImport ::= [
    "boolean": "",
    "byte": "import java.util.IntSummaryStatistics;",
    "short": "import java.util.IntSummaryStatistics;",
    "char": "import java.util.IntSummaryStatistics;",
    "int": "import java.util.IntSummaryStatistics;",
    "long": "import java.util.LongSummaryStatistics;",
    "float": "import java.util.DoubleSummaryStatistics;",
    "double": "import java.util.DoubleSummaryStatistics;",
    default: "no matching wide type"
]
