import "copyrightAndOthers.stg"
import "primitiveLiteral.stg"

skipBoolean() ::= "true"

isTest() ::= "true"

targetPath() ::= "org/eclipse/collections/impl/map/primitive"

fileName(primitive) ::= "Abstract<primitive.name>ObjectMapKeyValuesViewTestCase"

class(primitive) ::= <<
<body(primitive.type, primitive.name)>
>>

body(type, name) ::= <<
<copyrightAndOthers()>

package org.eclipse.collections.impl.map.primitive;

import java.util.Iterator;
import java.util.NoSuchElementException;
import java.util.concurrent.atomic.AtomicInteger;

import org.eclipse.collections.api.BooleanIterable;
import org.eclipse.collections.api.ByteIterable;
import org.eclipse.collections.api.CharIterable;
import org.eclipse.collections.api.DoubleIterable;
import org.eclipse.collections.api.FloatIterable;
import org.eclipse.collections.api.IntIterable;
import org.eclipse.collections.api.LongIterable;
import org.eclipse.collections.api.RichIterable;
import org.eclipse.collections.api.ShortIterable;
import org.eclipse.collections.api.bag.MutableBag;
import org.eclipse.collections.api.bag.sorted.MutableSortedBag;
import org.eclipse.collections.api.bimap.MutableBiMap;
import org.eclipse.collections.api.block.function.Function;
import org.eclipse.collections.api.block.function.Function0;
import org.eclipse.collections.api.block.function.Function2;
import org.eclipse.collections.api.block.procedure.Procedure2;
import org.eclipse.collections.api.list.MutableList;
import org.eclipse.collections.api.map.MapIterable;
import org.eclipse.collections.api.map.MutableMap;
import org.eclipse.collections.api.map.primitive.<name>ObjectMap;
import org.eclipse.collections.api.map.sorted.MutableSortedMap;
import org.eclipse.collections.api.multimap.Multimap;
import org.eclipse.collections.api.partition.PartitionIterable;
import org.eclipse.collections.api.set.MutableSet;
import org.eclipse.collections.api.set.sorted.MutableSortedSet;
import org.eclipse.collections.api.tuple.Pair;
import org.eclipse.collections.api.tuple.primitive.<name>ObjectPair;
import org.eclipse.collections.impl.bag.mutable.HashBag;
import org.eclipse.collections.impl.bag.mutable.primitive.BooleanHashBag;
import org.eclipse.collections.impl.bag.mutable.primitive.ByteHashBag;
import org.eclipse.collections.impl.bag.mutable.primitive.CharHashBag;
import org.eclipse.collections.impl.bag.mutable.primitive.DoubleHashBag;
import org.eclipse.collections.impl.bag.mutable.primitive.FloatHashBag;
import org.eclipse.collections.impl.bag.mutable.primitive.IntHashBag;
import org.eclipse.collections.impl.bag.mutable.primitive.LongHashBag;
import org.eclipse.collections.impl.bag.mutable.primitive.ShortHashBag;
import org.eclipse.collections.impl.bag.sorted.mutable.TreeBag;
import org.eclipse.collections.impl.bimap.mutable.HashBiMap;
import org.eclipse.collections.impl.block.factory.Comparators;
import org.eclipse.collections.impl.block.factory.Functions0;
import org.eclipse.collections.impl.block.factory.Predicates;
import org.eclipse.collections.impl.block.factory.Predicates2;
import org.eclipse.collections.impl.block.procedure.CollectionAddProcedure;
import org.eclipse.collections.impl.factory.Bags;
import org.eclipse.collections.impl.factory.Lists;
import org.eclipse.collections.impl.list.Interval;
import org.eclipse.collections.impl.list.mutable.FastList;
import org.eclipse.collections.impl.map.mutable.UnifiedMap;
import org.eclipse.collections.impl.map.sorted.mutable.TreeSortedMap;
import org.eclipse.collections.impl.set.mutable.UnifiedSet;
import org.eclipse.collections.impl.set.sorted.mutable.TreeSortedSet;
import org.eclipse.collections.impl.test.Verify;
import org.eclipse.collections.impl.tuple.Tuples;
import org.eclipse.collections.impl.tuple.primitive.PrimitiveTuples;

import org.junit.Test;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertThrows;
import static org.junit.Assert.assertNull;

/**
 * Abstract JUnit test for {@link <name>ObjectMap#keyValuesView()}.
 * This file was automatically generated from template file abstractPrimitiveObjectMapKeyValuesViewTestCase.stg.
 */
public abstract class Abstract<name>ObjectMapKeyValuesViewTestCase
{
    public abstract <name>ObjectMap\<Integer> newWithKeysValues(<type> key1, int value1, <type> key2, int value2, <type> key3, int value3);

    public abstract <name>ObjectMap\<Integer> newWithKeysValues(<type> key1, int value1, <type> key2, int value2);

    public abstract <name>ObjectMap\<Integer> newWithKeysValues(<type> key1, int value1);

    public abstract <name>ObjectMap\<Integer> newEmpty();

    public RichIterable\<<name>ObjectPair\<Integer>\> newWith()
    {
        return this.newEmpty().keyValuesView();
    }

    public RichIterable\<<name>ObjectPair\<Integer>\> newWith(<type> key1, int value1)
    {
        return this.newWithKeysValues(key1, value1).keyValuesView();
    }

    public RichIterable\<<name>ObjectPair\<Integer>\> newWith(<type> key1, int value1, <type> key2, int value2)
    {
        return this.newWithKeysValues(key1, value1, key2, value2).keyValuesView();
    }

    public RichIterable\<<name>ObjectPair\<Integer>\> newWith(<type> key1, int value1, <type> key2, int value2, <type> key3, int value3)
    {
        return this.newWithKeysValues(key1, value1, key2, value2, key3, value3).keyValuesView();
    }

    @Test
    public void containsAllIterable()
    {
        RichIterable\<<name>ObjectPair\<Integer>\> collection = this.newWith(<(literal.(type))("1")>, 2, <(literal.(type))("2")>, 3, <(literal.(type))("3")>, 4);
        assertTrue(collection.containsAllIterable(FastList.newListWith(PrimitiveTuples.pair(<(literal.(type))("1")>, Integer.valueOf(2)), PrimitiveTuples.pair(<(literal.(type))("2")>, Integer.valueOf(3)))));
        assertFalse(collection.containsAllIterable(FastList.newListWith(PrimitiveTuples.pair(<(literal.(type))("1")>, Integer.valueOf(2)), PrimitiveTuples.pair(<(literal.(type))("1")>, Integer.valueOf(5)))));
    }

    @Test
    public void containsAllArray()
    {
        RichIterable\<<name>ObjectPair\<Integer>\> collection = this.newWith(<(literal.(type))("1")>, 2, <(literal.(type))("2")>, 3, <(literal.(type))("3")>, 4);
        assertTrue(collection.containsAllArguments(PrimitiveTuples.pair(<(literal.(type))("1")>, Integer.valueOf(2)), PrimitiveTuples.pair(<(literal.(type))("2")>, Integer.valueOf(3))));
        assertFalse(collection.containsAllArguments(PrimitiveTuples.pair(<(literal.(type))("1")>, Integer.valueOf(2)), PrimitiveTuples.pair(<(literal.(type))("1")>, Integer.valueOf(5))));
    }

    @Test
    public void forEach()
    {
        MutableList\<<name>ObjectPair\<Integer>\> result = Lists.mutable.of();
        RichIterable\<<name>ObjectPair\<Integer>\> collection = this.newWith(<(literal.(type))("1")>, 2, <(literal.(type))("2")>, 3, <(literal.(type))("3")>, 4);
        collection.forEach(CollectionAddProcedure.on(result));
        Verify.assertSize(3, result);
        Verify.assertContainsAll(result, PrimitiveTuples.pair(<(literal.(type))("1")>, Integer.valueOf(2)), PrimitiveTuples.pair(<(literal.(type))("2")>, Integer.valueOf(3)), PrimitiveTuples.pair(<(literal.(type))("3")>, Integer.valueOf(4)));

        MutableList\<<name>ObjectPair\<Integer>\> result2 = Lists.mutable.of();
        RichIterable\<<name>ObjectPair\<Integer>\> collection2 = this.newWith(<(literal.(type))("0")>, 2, <(literal.(type))("2")>, 3, <(literal.(type))("3")>, 4);
        collection2.forEach(CollectionAddProcedure.on(result2));
        Verify.assertSize(3, result2);
        Verify.assertContainsAll(result2, PrimitiveTuples.pair(<(literal.(type))("0")>, Integer.valueOf(2)), PrimitiveTuples.pair(<(literal.(type))("2")>, Integer.valueOf(3)), PrimitiveTuples.pair(<(literal.(type))("3")>, Integer.valueOf(4)));
    }

    @Test
    public void forEachWith()
    {
        MutableBag\<<name>ObjectPair\<Integer>\> result = Bags.mutable.of();
        MutableBag\<Integer> result2 = Bags.mutable.of();
        RichIterable\<<name>ObjectPair\<Integer>\> collection = this.newWith(<(literal.(type))("1")>, 2, <(literal.(type))("2")>, 3, <(literal.(type))("3")>, 4);
        collection.forEachWith((<name>ObjectPair\<Integer> argument1, Integer argument2) ->
        {
            result.add(argument1);
            result2.add(argument2);
        }, 0);

        assertEquals(Bags.immutable.of(PrimitiveTuples.pair(<(literal.(type))("1")>, Integer.valueOf(2)), PrimitiveTuples.pair(<(literal.(type))("2")>, Integer.valueOf(3)), PrimitiveTuples.pair(<(literal.(type))("3")>, Integer.valueOf(4))), result);
        assertEquals(Bags.immutable.of(0, 0, 0), result2);

        MutableBag\<<name>ObjectPair\<Integer>\> result3 = Bags.mutable.of();
        MutableBag\<Integer> result4 = Bags.mutable.of();
        RichIterable\<<name>ObjectPair\<Integer>\> collection2 = this.newWith(<(literal.(type))("4")>, 2, <(literal.(type))("2")>, 3, <(literal.(type))("3")>, 4);
        collection2.forEachWith((<name>ObjectPair\<Integer> argument1, Integer argument2) ->
        {
            result3.add(argument1);
            result4.add(argument2);
        }, 0);

        assertEquals(Bags.immutable.of(PrimitiveTuples.pair(<(literal.(type))("4")>, Integer.valueOf(2)), PrimitiveTuples.pair(<(literal.(type))("2")>, Integer.valueOf(3)), PrimitiveTuples.pair(<(literal.(type))("3")>, Integer.valueOf(4))), result3);
        assertEquals(Bags.immutable.of(0, 0, 0), result4);
    }

    @Test
    public void forEachWithIndex()
    {
        MutableBag\<<name>ObjectPair\<Integer>\> elements = Bags.mutable.of();
        MutableBag\<Integer> indexes = Bags.mutable.of();
        RichIterable\<<name>ObjectPair\<Integer>\> collection = this.newWith(<(literal.(type))("1")>, 2, <(literal.(type))("0")>, 3, <(literal.(type))("3")>, 4);
        collection.forEachWithIndex((<name>ObjectPair\<Integer> object, int index) ->
        {
            elements.add(object);
            indexes.add(index);
        });
        assertEquals(Bags.mutable.of(PrimitiveTuples.pair(<(literal.(type))("1")>, Integer.valueOf(2)), PrimitiveTuples.pair(<(literal.(type))("0")>, Integer.valueOf(3)), PrimitiveTuples.pair(<(literal.(type))("3")>, Integer.valueOf(4))), elements);
        assertEquals(Bags.mutable.of(0, 1, 2), indexes);

        MutableBag\<<name>ObjectPair\<Integer>\> elements2 = Bags.mutable.of();
        MutableBag\<Integer> indexes2 = Bags.mutable.of();
        RichIterable\<<name>ObjectPair\<Integer>\> collection2 = this.newWith(<(literal.(type))("2")>, 2, <(literal.(type))("5")>, 3, <(literal.(type))("3")>, 4);
        collection2.forEachWithIndex((<name>ObjectPair\<Integer> object, int index) ->
        {
            elements2.add(object);
            indexes2.add(index);
        });
        assertEquals(Bags.mutable.of(PrimitiveTuples.pair(<(literal.(type))("2")>, Integer.valueOf(2)), PrimitiveTuples.pair(<(literal.(type))("5")>, Integer.valueOf(3)), PrimitiveTuples.pair(<(literal.(type))("3")>, Integer.valueOf(4))), elements2);
        assertEquals(Bags.mutable.of(0, 1, 2), indexes2);
    }

    @Test
    public void select()
    {
        MutableList\<<name>ObjectPair\<Integer>\> result = this.newWith(<(literal.(type))("1")>, 2, <(literal.(type))("2")>, 3, <(literal.(type))("3")>, 4).select(Predicates.equal(PrimitiveTuples.pair(<(literal.(type))("2")>, Integer.valueOf(3)))).toList();
        Verify.assertContains(PrimitiveTuples.pair(<(literal.(type))("2")>, Integer.valueOf(3)), result);
        Verify.assertNotContains(PrimitiveTuples.pair(<(literal.(type))("1")>, Integer.valueOf(2)), result);
        Verify.assertNotContains(PrimitiveTuples.pair(<(literal.(type))("3")>, Integer.valueOf(4)), result);
    }

    @Test
    public void selectWith()
    {
        MutableList\<<name>ObjectPair\<Integer>\> result = this.newWith(<(literal.(type))("1")>, 2, <(literal.(type))("2")>, 3, <(literal.(type))("3")>, 4).selectWith(Object::equals, PrimitiveTuples.pair(<(literal.(type))("2")>, Integer.valueOf(3))).toList();
        Verify.assertContains(PrimitiveTuples.pair(<(literal.(type))("2")>, Integer.valueOf(3)), result);
        Verify.assertNotContains(PrimitiveTuples.pair(<(literal.(type))("1")>, Integer.valueOf(2)), result);
        Verify.assertNotContains(PrimitiveTuples.pair(<(literal.(type))("3")>, Integer.valueOf(4)), result);
    }

    @Test
    public void selectWith_target()
    {
        HashBag\<<name>ObjectPair\<Integer>\> result = this.newWith(<(literal.(type))("1")>, 2, <(literal.(type))("2")>, 3, <(literal.(type))("3")>, 4).selectWith(Predicates2.notEqual(), PrimitiveTuples.pair(<(literal.(type))("2")>, Integer.valueOf(3)), HashBag.\<<name>ObjectPair\<Integer>\>newBag());
        assertEquals(Bags.immutable.of(PrimitiveTuples.pair(<(literal.(type))("1")>, Integer.valueOf(2)), PrimitiveTuples.pair(<(literal.(type))("3")>, Integer.valueOf(4))), result);
    }

    @Test
    public void reject()
    {
        MutableList\<<name>ObjectPair\<Integer>\> result = this.newWith(<(literal.(type))("1")>, 2, <(literal.(type))("2")>, 3, <(literal.(type))("3")>, 4).reject(Predicates.notEqual(PrimitiveTuples.pair(<(literal.(type))("2")>, Integer.valueOf(3)))).toList();
        Verify.assertContains(PrimitiveTuples.pair(<(literal.(type))("2")>, Integer.valueOf(3)), result);
        Verify.assertNotContains(PrimitiveTuples.pair(<(literal.(type))("1")>, Integer.valueOf(2)), result);
        Verify.assertNotContains(PrimitiveTuples.pair(<(literal.(type))("3")>, Integer.valueOf(4)), result);
    }

    @Test
    public void rejectWith()
    {
        MutableList\<<name>ObjectPair\<Integer>\> result = this.newWith(<(literal.(type))("1")>, 2, <(literal.(type))("2")>, 3, <(literal.(type))("3")>, 4).rejectWith(Predicates2.notEqual(), PrimitiveTuples.pair(<(literal.(type))("2")>, Integer.valueOf(3))).toList();
        Verify.assertContains(PrimitiveTuples.pair(<(literal.(type))("2")>, Integer.valueOf(3)), result);
        Verify.assertNotContains(PrimitiveTuples.pair(<(literal.(type))("1")>, Integer.valueOf(2)), result);
        Verify.assertNotContains(PrimitiveTuples.pair(<(literal.(type))("3")>, Integer.valueOf(4)), result);
    }

    @Test
    public void rejectWith_target()
    {
        HashBag\<<name>ObjectPair\<Integer>\> result = this.newWith(<(literal.(type))("1")>, 2, <(literal.(type))("2")>, 3, <(literal.(type))("3")>, 4).rejectWith(Object::equals, PrimitiveTuples.pair(<(literal.(type))("2")>, Integer.valueOf(3)), HashBag.\<<name>ObjectPair\<Integer>\>newBag());
        assertEquals(Bags.immutable.of(PrimitiveTuples.pair(<(literal.(type))("1")>, Integer.valueOf(2)), PrimitiveTuples.pair(<(literal.(type))("3")>, Integer.valueOf(4))), result);
    }

    @Test
    public void selectInstancesOf()
    {
        RichIterable\<<name>ObjectPair\<Integer>\> pairs = this.newWith(<(literal.(type))("1")>, 2, <(literal.(type))("2")>, 3, <(literal.(type))("3")>, 4);
        Verify.assertIterableEmpty(pairs.selectInstancesOf(Integer.class));
        Verify.assertContainsAll(pairs.selectInstancesOf(<name>ObjectPair.class), PrimitiveTuples.pair(<(literal.(type))("1")>, Integer.valueOf(2)), PrimitiveTuples.pair(<(literal.(type))("3")>, Integer.valueOf(4)), PrimitiveTuples.pair(<(literal.(type))("2")>, Integer.valueOf(3)));
    }

    @Test
    public void collect()
    {
        RichIterable\<<name>ObjectPair\<Integer>\> pairs = this.newWith(<(literal.(type))("1")>, 2, <(literal.(type))("2")>, 3, <(literal.(type))("3")>, 4);

        RichIterable\<Integer> result1 = pairs.collect((<name>ObjectPair\<Integer> object) -> (int) object.getOne());
        assertEquals(Bags.immutable.of(1, 2, 3), result1.toBag());
        RichIterable\<Integer> result2 = pairs.collect(<name>ObjectPair::getTwo);
        assertEquals(Bags.immutable.of(2, 3, 4), result2.toBag());
    }

    @Test
    public void collectBoolean()
    {
        BooleanIterable result =
                this.newWith(<(literal.(type))("1")>, 2, <(literal.(type))("2")>, 3, <(literal.(type))("3")>, 4).collectBoolean((<name>ObjectPair\<Integer> each) -> (each.getOne() % 2) == 0);
        assertEquals(BooleanHashBag.newBagWith(true, false, false), result.toBag());
    }

    @Test
    public void collectByte()
    {
        ByteIterable result =
                this.newWith(<(literal.(type))("1")>, 2, <(literal.(type))("2")>, 3, <(literal.(type))("3")>, 4).collectByte((<name>ObjectPair\<Integer> anObject) -> (byte) anObject.getOne());
        assertEquals(ByteHashBag.newBagWith((byte) 1, (byte) 2, (byte) 3), result.toBag());
    }

    @Test
    public void collectChar()
    {
        CharIterable result =
                this.newWith(<(literal.(type))("1")>, 2, <(literal.(type))("2")>, 3, <(literal.(type))("3")>, 4).collectChar((<name>ObjectPair\<Integer> anObject) -> (char) anObject.getOne());
        assertEquals(CharHashBag.newBagWith((char) 1, (char) 2, (char) 3), result.toBag());
    }

    @Test
    public void collectDouble()
    {
        DoubleIterable result =
                this.newWith(<(literal.(type))("1")>, 2, <(literal.(type))("2")>, 3, <(literal.(type))("3")>, 4).collectDouble((<name>ObjectPair\<Integer> anObject) -> (double) anObject.getOne());
        assertEquals(DoubleHashBag.newBagWith(1.0, 2.0, 3.0), result.toBag());
    }

    @Test
    public void collectFloat()
    {
        FloatIterable result =
                this.newWith(<(literal.(type))("1")>, 2, <(literal.(type))("2")>, 3, <(literal.(type))("3")>, 4).collectFloat((<name>ObjectPair\<Integer> anObject) -> (float) anObject.getOne());
        assertEquals(FloatHashBag.newBagWith(1.0f, 2.0f, 3.0f), result.toBag());
    }

    @Test
    public void collectInt()
    {
        IntIterable result =
                this.newWith(<(literal.(type))("1")>, 2, <(literal.(type))("2")>, 3, <(literal.(type))("3")>, 4).collectInt((<name>ObjectPair\<Integer> anObject) -> (int) anObject.getOne());
        assertEquals(IntHashBag.newBagWith(1, 2, 3), result.toBag());
    }

    @Test
    public void collectLong()
    {
        LongIterable result =
                this.newWith(<(literal.(type))("1")>, 2, <(literal.(type))("2")>, 3, <(literal.(type))("3")>, 4).collectLong((<name>ObjectPair\<Integer> anObject) -> (long) anObject.getOne());
        assertEquals(LongHashBag.newBagWith(1L, 2L, 3L), result.toBag());
    }

    @Test
    public void collectShort()
    {
        ShortIterable result =
                this.newWith(<(literal.(type))("1")>, 2, <(literal.(type))("2")>, 3, <(literal.(type))("3")>, 4).collectShort((<name>ObjectPair\<Integer> anObject) -> (short) anObject.getOne());
        assertEquals(ShortHashBag.newBagWith((short) 1, (short) 2, (short) 3), result.toBag());
    }

    @Test
    public void flatCollect()
    {
        RichIterable\<<name>ObjectPair\<Integer>\> collection = this.newWith(<(literal.(type))("1")>, 2, <(literal.(type))("2")>, 3, <(literal.(type))("3")>, 4);
        Function\<<name>ObjectPair\<Integer>, MutableList\<String>\> function = (<name>ObjectPair\<Integer> object) -> FastList.newListWith(String.valueOf(object));

        Verify.assertListsEqual(
                FastList.newListWith("<(toStringLiteral.(type))("1")>:2", "<(toStringLiteral.(type))("2")>:3", "<(toStringLiteral.(type))("3")>:4"),
                collection.flatCollect(function).toSortedList());

        Verify.assertSetsEqual(
                UnifiedSet.newSetWith("<(toStringLiteral.(type))("1")>:2", "<(toStringLiteral.(type))("2")>:3", "<(toStringLiteral.(type))("3")>:4"),
                collection.flatCollect(function, UnifiedSet.\<String>newSet()));
    }

    @Test
    public void detect()
    {
        assertEquals(PrimitiveTuples.pair(<(literal.(type))("2")>, Integer.valueOf(3)), this.newWith(<(literal.(type))("1")>, 2, <(literal.(type))("2")>, 3, <(literal.(type))("3")>, 4).detect(Predicates.equal(PrimitiveTuples.pair(<(literal.(type))("2")>, Integer.valueOf(3)))));
        assertNull(this.newWith(<(literal.(type))("1")>, 2, <(literal.(type))("2")>, 3, <(literal.(type))("3")>, 4).detect(Predicates.equal(PrimitiveTuples.pair(<(literal.(type))("2")>, Integer.valueOf(4)))));
    }

    @Test
    public void min_empty_throws()
    {
        assertThrows(NoSuchElementException.class, () -> this.newWith().min(Comparators.naturalOrder()));
    }

    @Test
    public void max_empty_throws()
    {
        assertThrows(NoSuchElementException.class, () -> this.newWith().max(Comparators.naturalOrder()));
    }

    @Test
    public void min()
    {
        assertEquals(PrimitiveTuples.pair(<(literal.(type))("1")>, Integer.valueOf(2)), this.newWith(<(literal.(type))("1")>, 2, <(literal.(type))("2")>, 3, <(literal.(type))("3")>, 4).min(Comparators.naturalOrder()));
    }

    @Test
    public void max()
    {
        assertEquals(PrimitiveTuples.pair(<(literal.(type))("3")>, Integer.valueOf(4)), this.newWith(<(literal.(type))("1")>, 2, <(literal.(type))("2")>, 3, <(literal.(type))("3")>, 4).max(Comparators.naturalOrder()));
    }

    @Test
    public void min_without_comparator()
    {
        assertEquals(PrimitiveTuples.pair(<(literal.(type))("1")>, Integer.valueOf(2)), this.newWith(<(literal.(type))("1")>, 2, <(literal.(type))("2")>, 3, <(literal.(type))("3")>, 4).min(Comparators.naturalOrder()));
    }

    @Test
    public void max_without_comparator()
    {
        assertEquals(PrimitiveTuples.pair(<(literal.(type))("3")>, Integer.valueOf(4)), this.newWith(<(literal.(type))("1")>, 2, <(literal.(type))("2")>, 3, <(literal.(type))("3")>, 4).max(Comparators.naturalOrder()));
    }

    @Test
    public void minBy()
    {
        assertEquals(
                PrimitiveTuples.pair(<(literal.(type))("2")>, Integer.valueOf(3)),
                this.newWith(<(literal.(type))("1")>, 2, <(literal.(type))("2")>, 3, <(literal.(type))("3")>, 4).minBy((<name>ObjectPair\<Integer> object) -> (int) object.getOne() & 1));
    }

    @Test
    public void maxBy()
    {
        assertEquals(
                PrimitiveTuples.pair(<(literal.(type))("1")>, Integer.valueOf(2)),
                this.newWith(<(literal.(type))("1")>, 2, <(literal.(type))("2")>, 3, <(literal.(type))("4")>, 5).maxBy((<name>ObjectPair\<Integer> object) -> (int) object.getOne() & 1));
    }

    @Test
    public void detectWith()
    {
        assertEquals(PrimitiveTuples.pair(<(literal.(type))("2")>, Integer.valueOf(3)), this.newWith(<(literal.(type))("1")>, 2, <(literal.(type))("2")>, 3, <(literal.(type))("3")>, 4).detectWith(Object::equals, PrimitiveTuples.pair(<(literal.(type))("2")>, Integer.valueOf(3))));
        assertNull(this.newWith(<(literal.(type))("1")>, 2, <(literal.(type))("2")>, 3, <(literal.(type))("3")>, 4).detectWith(Object::equals, PrimitiveTuples.pair(<(literal.(type))("2")>, Integer.valueOf(4))));
    }

    @Test
    public void detectIfNone()
    {
        Function0\<<name>ObjectPair\<Integer>\> function = Functions0.value(PrimitiveTuples.pair(<(literal.(type))("5")>, Integer.valueOf(6)));
        assertEquals(PrimitiveTuples.pair(<(literal.(type))("2")>, Integer.valueOf(3)), this.newWith(<(literal.(type))("1")>, 2, <(literal.(type))("2")>, 3, <(literal.(type))("3")>, 4).detectIfNone(Predicates.equal(PrimitiveTuples.pair(<(literal.(type))("2")>, Integer.valueOf(3))), function));
        assertEquals(PrimitiveTuples.pair(<(literal.(type))("5")>, Integer.valueOf(6)), this.newWith(<(literal.(type))("1")>, 2, <(literal.(type))("2")>, 3, <(literal.(type))("3")>, 4).detectIfNone(Predicates.equal(PrimitiveTuples.pair(<(literal.(type))("2")>, Integer.valueOf(4))), function));
    }

    @Test
    public void detectWithIfNoneBlock()
    {
        Function0\<<name>ObjectPair\<Integer>\> function = Functions0.value(PrimitiveTuples.pair(<(literal.(type))("5")>, Integer.valueOf(6)));
        assertEquals(PrimitiveTuples.pair(<(literal.(type))("2")>, Integer.valueOf(3)), this.newWith(<(literal.(type))("1")>, 2, <(literal.(type))("2")>, 3, <(literal.(type))("3")>, 4).detectWithIfNone(
                Object::equals,
                PrimitiveTuples.pair(<(literal.(type))("2")>, Integer.valueOf(3)),
                function));
        assertEquals(PrimitiveTuples.pair(<(literal.(type))("5")>, Integer.valueOf(6)), this.newWith(<(literal.(type))("1")>, 2, <(literal.(type))("2")>, 3, <(literal.(type))("3")>, 4).detectWithIfNone(
                Object::equals,
                PrimitiveTuples.pair(<(literal.(type))("2")>, Integer.valueOf(4)),
                function));
    }

    @Test
    public void allSatisfy()
    {
        assertTrue(this.newWith(<(literal.(type))("1")>, 2, <(literal.(type))("2")>, 3, <(literal.(type))("3")>, 4).allSatisfy(<name>ObjectPair.class::isInstance));
        assertFalse(this.newWith(<(literal.(type))("1")>, 2, <(literal.(type))("2")>, 3, <(literal.(type))("3")>, 4).allSatisfy(Predicates.equal(PrimitiveTuples.pair(<(literal.(type))("2")>, Integer.valueOf(3)))));
    }

    @Test
    public void allSatisfyWith()
    {
        assertTrue(this.newWith(<(literal.(type))("1")>, 2, <(literal.(type))("2")>, 3, <(literal.(type))("3")>, 4).allSatisfyWith(Predicates2.instanceOf(), <name>ObjectPair.class));
        assertFalse(this.newWith(<(literal.(type))("1")>, 2, <(literal.(type))("2")>, 3, <(literal.(type))("3")>, 4).allSatisfyWith(Object::equals, PrimitiveTuples.pair(<(literal.(type))("2")>, Integer.valueOf(3))));
    }

    @Test
    public void noneSatisfy()
    {
        assertTrue(this.newWith(<(literal.(type))("1")>, 2, <(literal.(type))("2")>, 3, <(literal.(type))("3")>, 4).noneSatisfy(Boolean.class::isInstance));
        assertFalse(this.newWith(<(literal.(type))("1")>, 2, <(literal.(type))("2")>, 3, <(literal.(type))("3")>, 4).noneSatisfy(Predicates.equal(PrimitiveTuples.pair(<(literal.(type))("2")>, Integer.valueOf(3)))));
    }

    @Test
    public void noneSatisfyWith()
    {
        assertTrue(this.newWith(<(literal.(type))("1")>, 2, <(literal.(type))("2")>, 3, <(literal.(type))("3")>, 4).noneSatisfyWith(Predicates2.instanceOf(), Boolean.class));
        assertFalse(this.newWith(<(literal.(type))("1")>, 2, <(literal.(type))("2")>, 3, <(literal.(type))("3")>, 4).noneSatisfyWith(Object::equals, PrimitiveTuples.pair(<(literal.(type))("2")>, Integer.valueOf(3))));
    }

    @Test
    public void anySatisfy()
    {
        assertTrue(this.newWith(<(literal.(type))("1")>, 2, <(literal.(type))("2")>, 3, <(literal.(type))("3")>, 4).anySatisfy(Predicates.equal(PrimitiveTuples.pair(<(literal.(type))("2")>, Integer.valueOf(3)))));
        assertFalse(this.newWith(<(literal.(type))("1")>, 2, <(literal.(type))("2")>, 3, <(literal.(type))("3")>, 4).anySatisfy(Predicates.equal(PrimitiveTuples.pair(<(literal.(type))("2")>, Integer.valueOf(5)))));
    }

    @Test
    public void anySatisfyWith()
    {
        assertTrue(this.newWith(<(literal.(type))("1")>, 2, <(literal.(type))("2")>, 3, <(literal.(type))("3")>, 4).anySatisfyWith(Object::equals, PrimitiveTuples.pair(<(literal.(type))("2")>, Integer.valueOf(3))));
        assertFalse(this.newWith(<(literal.(type))("1")>, 2, <(literal.(type))("2")>, 3, <(literal.(type))("3")>, 4).anySatisfyWith(Object::equals, PrimitiveTuples.pair(<(literal.(type))("2")>, Integer.valueOf(5))));
    }

    @Test
    public void count()
    {
        assertEquals(0, this.newWith(<(literal.(type))("1")>, 2, <(literal.(type))("2")>, 3, <(literal.(type))("3")>, 4).count(Boolean.class::isInstance));
        assertEquals(3, this.newWith(<(literal.(type))("1")>, 2, <(literal.(type))("2")>, 3, <(literal.(type))("3")>, 4).count(<name>ObjectPair.class::isInstance));
        assertEquals(1, this.newWith(<(literal.(type))("1")>, 2, <(literal.(type))("2")>, 3, <(literal.(type))("3")>, 4).count(Predicates.equal(PrimitiveTuples.pair(<(literal.(type))("2")>, Integer.valueOf(3)))));
    }

    @Test
    public void countWith()
    {
        assertEquals(0, this.newWith(<(literal.(type))("1")>, 2, <(literal.(type))("2")>, 3, <(literal.(type))("3")>, 4).countWith(Predicates2.instanceOf(), Boolean.class));
        assertEquals(3, this.newWith(<(literal.(type))("1")>, 2, <(literal.(type))("2")>, 3, <(literal.(type))("3")>, 4).countWith(Predicates2.instanceOf(), <name>ObjectPair.class));
        assertEquals(1, this.newWith(<(literal.(type))("1")>, 2, <(literal.(type))("2")>, 3, <(literal.(type))("3")>, 4).countWith(Object::equals, PrimitiveTuples.pair(<(literal.(type))("2")>, Integer.valueOf(3))));
    }

    @Test
    public void collectIf()
    {
        Verify.assertContainsAll(
                this.newWith(<(literal.(type))("1")>, 2, <(literal.(type))("2")>, 3, <(literal.(type))("3")>, 4).collectIf(
                        <name>ObjectPair.class::isInstance,
                        String::valueOf),
                "<(toStringLiteral.(type))("1")>:2", "<(toStringLiteral.(type))("2")>:3", "<(toStringLiteral.(type))("3")>:4");
        Verify.assertContainsAll(
                this.newWith(<(literal.(type))("1")>, 2, <(literal.(type))("2")>, 3, <(literal.(type))("3")>, 4).collectIf(
                        <name>ObjectPair.class::isInstance,
                        String::valueOf,
                        UnifiedSet.\<String>newSet()),
                "<(toStringLiteral.(type))("1")>:2", "<(toStringLiteral.(type))("2")>:3", "<(toStringLiteral.(type))("3")>:4");
    }

    @Test
    public void collectWith()
    {
        assertEquals(
                Bags.mutable.of(4L, 6L, 8L),
                this.newWith(<(literal.(type))("1")>, 2, <(literal.(type))("2")>, 3, <(literal.(type))("3")>, 4)
                      .collectWith((<name>ObjectPair\<Integer> argument1, Long argument2) -> (long) (argument1.getOne() + argument1.getTwo() + argument2), 1L).toBag());
    }

    @Test
    public void collectWith_target()
    {
        assertEquals(
                Bags.mutable.of(4L, 6L, 8L),
                this.newWith(<(literal.(type))("1")>, 2, <(literal.(type))("2")>, 3, <(literal.(type))("3")>, 4)
                       .collectWith((<name>ObjectPair\<Integer> argument1, Long argument2) -> (long) (argument1.getOne() + argument1.getTwo() + argument2), 1L, HashBag.\<Long>newBag()));
    }

    @Test
    public void getFirst()
    {
        <name>ObjectPair\<Integer> first = this.newWith(<(literal.(type))("1")>, 2, <(literal.(type))("2")>, 3, <(literal.(type))("3")>, 4).getFirst();
        assertTrue(PrimitiveTuples.pair(<(literal.(type))("1")>, Integer.valueOf(2)).equals(first)
                || PrimitiveTuples.pair(<(literal.(type))("2")>, Integer.valueOf(3)).equals(first)
                || PrimitiveTuples.pair(<(literal.(type))("3")>, Integer.valueOf(4)).equals(first));
        assertEquals(PrimitiveTuples.pair(<(literal.(type))("1")>, Integer.valueOf(2)), this.newWith(<(literal.(type))("1")>, 2).getFirst());
    }

    @Test
    public void getLast()
    {
        <name>ObjectPair\<Integer> last = this.newWith(<(literal.(type))("1")>, 2, <(literal.(type))("2")>, 3, <(literal.(type))("3")>, 4).getLast();
        assertTrue(PrimitiveTuples.pair(<(literal.(type))("1")>, Integer.valueOf(2)).equals(last)
                || PrimitiveTuples.pair(<(literal.(type))("2")>, Integer.valueOf(3)).equals(last)
                || PrimitiveTuples.pair(<(literal.(type))("3")>, Integer.valueOf(4)).equals(last));
        assertEquals(PrimitiveTuples.pair(<(literal.(type))("1")>, Integer.valueOf(2)), this.newWith(<(literal.(type))("1")>, 2).getLast());
    }

    @Test
    public void isEmpty()
    {
        Verify.assertIterableEmpty(this.newWith());
        Verify.assertIterableNotEmpty(this.newWith(<(literal.(type))("1")>, 2));
        assertTrue(this.newWith(<(literal.(type))("1")>, 2).notEmpty());
    }

    @Test
    public void iterator()
    {
        RichIterable\<<name>ObjectPair\<Integer>\> objects = this.newWith(<(literal.(type))("1")>, 2, <(literal.(type))("0")>, 3, <(literal.(type))("3")>, 4);
        MutableBag\<<name>ObjectPair\<Integer>\> actual = Bags.mutable.of();
        Iterator\<<name>ObjectPair\<Integer>\> iterator = objects.iterator();
        for (int i = objects.size(); i-- > 0; )
        {
            assertTrue(iterator.hasNext());
            actual.add(iterator.next());
        }
        assertFalse(iterator.hasNext());
        assertEquals(objects.toBag(), actual);
    }

    @Test
    public void iterator_no_sentinels()
    {
        RichIterable\<<name>ObjectPair\<Integer>\> objects = this.newWith(<(literal.(type))("2")>, 2, <(literal.(type))("4")>, 3, <(literal.(type))("3")>, 4);
        MutableBag\<<name>ObjectPair\<Integer>\> actual = Bags.mutable.of();
        Iterator\<<name>ObjectPair\<Integer>\> iterator = objects.iterator();
        for (int i = objects.size(); i-- > 0; )
        {
            assertTrue(iterator.hasNext());
            actual.add(iterator.next());
        }
        assertFalse(iterator.hasNext());
        assertEquals(objects.toBag(), actual);
    }

    @Test
    public void iterator_next_throws()
    {
        RichIterable\<<name>ObjectPair\<Integer>\> objects = this.newWith(<(literal.(type))("1")>, 2, <(literal.(type))("2")>, 3, <(literal.(type))("3")>, 4);
        Iterator\<<name>ObjectPair\<Integer>\> iterator = objects.iterator();
        for (int i = objects.size(); i-- > 0; )
        {
            assertTrue(iterator.hasNext());
            iterator.next();
        }
        assertFalse(iterator.hasNext());
        assertThrows(NoSuchElementException.class, () -> iterator.next());
    }

    @Test
    public void iterator_remove_throws()
    {
        RichIterable\<<name>ObjectPair\<Integer>\> objects = this.newWith(<(literal.(type))("1")>, 2, <(literal.(type))("2")>, 3, <(literal.(type))("3")>, 4);
        Iterator\<<name>ObjectPair\<Integer>\> iterator = objects.iterator();
        assertThrows(UnsupportedOperationException.class, () -> iterator.remove());
    }

    @Test
    public void injectInto()
    {
        RichIterable\<<name>ObjectPair\<Integer>\> objects = this.newWith(<(literal.(type))("1")>, 2, <(literal.(type))("2")>, 3, <(literal.(type))("3")>, 4);
        Long result = objects.injectInto(1L, (Long argument1, <name>ObjectPair\<Integer> argument2) -> (long) (argument1 + argument2.getOne() + argument2.getTwo()));
        assertEquals(Long.valueOf(16), result);
    }

    @Test
    public void injectIntoInt()
    {
        RichIterable\<<name>ObjectPair\<Integer>\> objects = this.newWith(<(literal.(type))("1")>, 2, <(literal.(type))("2")>, 3, <(literal.(type))("3")>, 4);
        int result = objects.injectInto(1, (int intParameter, <name>ObjectPair\<Integer> argument2) -> (int) (intParameter + argument2.getOne() + argument2.getTwo()));
        assertEquals(16, result);
    }

    @Test
    public void injectIntoLong()
    {
        RichIterable\<<name>ObjectPair\<Integer>\> objects = this.newWith(<(literal.(type))("1")>, 2, <(literal.(type))("2")>, 3, <(literal.(type))("3")>, 4);
        long result = objects.injectInto(1L, (long parameter, <name>ObjectPair\<Integer> argument2) -> (long) (parameter + argument2.getOne() + argument2.getTwo()));
        assertEquals(16, result);
    }

    @Test
    public void injectIntoDouble()
    {
        RichIterable\<<name>ObjectPair\<Integer>\> objects = this.newWith(<(literal.(type))("1")>, 2, <(literal.(type))("2")>, 3, <(literal.(type))("3")>, 4);
        double result = objects.injectInto(1.0, (double parameter, <name>ObjectPair\<Integer> argument2) -> (double) (parameter + argument2.getOne() + argument2.getTwo()));
        assertEquals(16.0, result, 0.0);
    }

    @Test
    public void injectIntoFloat()
    {
        RichIterable\<<name>ObjectPair\<Integer>\> objects = this.newWith(<(literal.(type))("1")>, 2, <(literal.(type))("2")>, 3, <(literal.(type))("3")>, 4);
        float result = objects.injectInto(1.0f, (float parameter, <name>ObjectPair\<Integer> argument2) -> (float) (parameter + argument2.getOne() + argument2.getTwo()));
        assertEquals(16.0, result, 0.0);
    }

    @Test
    public void sumFloat()
    {
        RichIterable\<<name>ObjectPair\<Integer>\> objects = this.newWith(<(literal.(type))("1")>, 2, <(literal.(type))("2")>, 3, <(literal.(type))("3")>, 4);
        double actual = objects.sumOfFloat((<name>ObjectPair\<Integer> each) -> (float) (each.getOne() + each.getTwo()));
        assertEquals(15.0, actual, 0.0);
    }

    @Test
    public void sumDouble()
    {
        RichIterable\<<name>ObjectPair\<Integer>\> objects = this.newWith(<(literal.(type))("1")>, 2, <(literal.(type))("2")>, 3, <(literal.(type))("3")>, 4);
        double actual = objects.sumOfDouble((<name>ObjectPair\<Integer> each) -> (double) (each.getOne() + each.getTwo()));
        assertEquals(15.0, actual, 0.0);
    }

    @Test
    public void sumInteger()
    {
        RichIterable\<<name>ObjectPair\<Integer>\> objects = this.newWith(<(literal.(type))("1")>, 2, <(literal.(type))("2")>, 3, <(literal.(type))("3")>, 4);
        long actual = objects.sumOfInt((<name>ObjectPair\<Integer> each) -> (int) (each.getOne() + each.getTwo()));
        assertEquals(15, actual);
    }

    @Test
    public void sumLong()
    {
        RichIterable\<<name>ObjectPair\<Integer>\> objects = this.newWith(<(literal.(type))("1")>, 2, <(literal.(type))("2")>, 3, <(literal.(type))("3")>, 4);
        long actual = objects.sumOfLong((<name>ObjectPair\<Integer> each) -> (long) (each.getOne() + each.getTwo()));
        assertEquals(15, actual);
    }

    @Test
    public void toArray()
    {
        RichIterable\<<name>ObjectPair\<Integer>\> objects = this.newWith(<(literal.(type))("1")>, 2, <(literal.(type))("2")>, 3, <(literal.(type))("3")>, 4);
        Object[] array = objects.toArray();
        Verify.assertSize(3, array);
        <name>ObjectPair\<Integer>[] array2 = objects.toArray(new <name>ObjectPair[3]);
        Verify.assertSize(3, array2);
    }

    @Test
    public void partition()
    {
        PartitionIterable\<<name>ObjectPair\<Integer>\> result = this.newWith(<(literal.(type))("1")>, 2, <(literal.(type))("2")>, 3, <(literal.(type))("3")>, 4).partition(Predicates.equal(PrimitiveTuples.pair(<(literal.(type))("2")>, Integer.valueOf(3))));
        Verify.assertContains(PrimitiveTuples.pair(<(literal.(type))("2")>, Integer.valueOf(3)), result.getSelected().toList());
        Verify.assertIterableSize(1, result.getSelected());
        Verify.assertContains(PrimitiveTuples.pair(<(literal.(type))("1")>, Integer.valueOf(2)), result.getRejected().toList());
        Verify.assertContains(PrimitiveTuples.pair(<(literal.(type))("3")>, Integer.valueOf(4)), result.getRejected().toList());
        Verify.assertIterableSize(2, result.getRejected());
    }

    @Test
    public void toList()
    {
        MutableList\<<name>ObjectPair\<Integer>\> list = this.newWith(<(literal.(type))("1")>, 2, <(literal.(type))("2")>, 3, <(literal.(type))("3")>, 4).toList();
        Verify.assertContainsAll(list, PrimitiveTuples.pair(<(literal.(type))("1")>, Integer.valueOf(2)), PrimitiveTuples.pair(<(literal.(type))("2")>, Integer.valueOf(3)), PrimitiveTuples.pair(<(literal.(type))("3")>, Integer.valueOf(4)));
    }

    @Test
    public void toBag()
    {
        MutableBag\<<name>ObjectPair\<Integer>\> bag = this.newWith(<(literal.(type))("1")>, 2, <(literal.(type))("2")>, 3, <(literal.(type))("3")>, 4).toBag();
        Verify.assertContainsAll(bag, PrimitiveTuples.pair(<(literal.(type))("1")>, Integer.valueOf(2)), PrimitiveTuples.pair(<(literal.(type))("2")>, Integer.valueOf(3)), PrimitiveTuples.pair(<(literal.(type))("3")>, Integer.valueOf(4)));
    }

    @Test
    public void toSortedList_natural_ordering()
    {
        RichIterable\<<name>ObjectPair\<Integer>\> pairs = this.newWith(<(literal.(type))("2")>, 3, <(literal.(type))("1")>, 2, <(literal.(type))("3")>, 4);
        MutableList\<<name>ObjectPair\<Integer>\> list = pairs.toSortedList();
        assertEquals(Lists.mutable.of(PrimitiveTuples.pair(<(literal.(type))("1")>, Integer.valueOf(2)), PrimitiveTuples.pair(<(literal.(type))("2")>, Integer.valueOf(3)), PrimitiveTuples.pair(<(literal.(type))("3")>, Integer.valueOf(4))), list);
    }

    @Test
    public void toSortedList_with_comparator()
    {
        RichIterable\<<name>ObjectPair\<Integer>\> pairs = this.newWith(<(literal.(type))("2")>, 3, <(literal.(type))("1")>, 2, <(literal.(type))("3")>, 4);
        MutableList\<<name>ObjectPair\<Integer>\> list = pairs.toSortedList(Comparators.reverseNaturalOrder());
        assertEquals(Lists.mutable.of(PrimitiveTuples.pair(<(literal.(type))("3")>, Integer.valueOf(4)), PrimitiveTuples.pair(<(literal.(type))("2")>, Integer.valueOf(3)), PrimitiveTuples.pair(<(literal.(type))("1")>, Integer.valueOf(2))), list);
    }

    @Test
    public void toSortedListBy()
    {
        RichIterable\<<name>ObjectPair\<Integer>\> pairs = this.newWith(<(literal.(type))("2")>, 3, <(literal.(type))("1")>, 2, <(literal.(type))("3")>, 4);
        MutableList\<<name>ObjectPair\<Integer>\> list = pairs.toSortedListBy(String::valueOf);
        assertEquals(Lists.mutable.of(PrimitiveTuples.pair(<(literal.(type))("1")>, Integer.valueOf(2)), PrimitiveTuples.pair(<(literal.(type))("2")>, Integer.valueOf(3)), PrimitiveTuples.pair(<(literal.(type))("3")>, Integer.valueOf(4))), list);
    }

    @Test
    public void toSortedBag_natural_ordering()
    {
        RichIterable\<<name>ObjectPair\<Integer>\> pairs = this.newWith(<(literal.(type))("2")>, 3, <(literal.(type))("1")>, 2, <(literal.(type))("3")>, 4);
        MutableSortedBag\<<name>ObjectPair\<Integer>\> bag = pairs.toSortedBag();
        Verify.assertSortedBagsEqual(TreeBag.newBagWith(PrimitiveTuples.pair(<(literal.(type))("1")>, Integer.valueOf(2)), PrimitiveTuples.pair(<(literal.(type))("2")>, Integer.valueOf(3)), PrimitiveTuples.pair(<(literal.(type))("3")>, Integer.valueOf(4))), bag);
    }

    @Test
    public void toSortedBag_with_comparator()
    {
        RichIterable\<<name>ObjectPair\<Integer>\> pairs = this.newWith(<(literal.(type))("2")>, 3, <(literal.(type))("1")>, 2, <(literal.(type))("3")>, 4);
        MutableSortedBag\<<name>ObjectPair\<Integer>\> bag = pairs.toSortedBag(Comparators.reverseNaturalOrder());
        Verify.assertSortedBagsEqual(TreeBag.newBagWith(Comparators.reverseNaturalOrder(), PrimitiveTuples.pair(<(literal.(type))("3")>, Integer.valueOf(4)), PrimitiveTuples.pair(<(literal.(type))("2")>, Integer.valueOf(3)), PrimitiveTuples.pair(<(literal.(type))("1")>, Integer.valueOf(2))), bag);
    }

    @Test
    public void toSortedBagBy()
    {
        RichIterable\<<name>ObjectPair\<Integer>\> pairs = this.newWith(<(literal.(type))("2")>, 3, <(literal.(type))("1")>, 2, <(literal.(type))("3")>, 4);
        MutableSortedBag\<<name>ObjectPair\<Integer>\> bag = pairs.toSortedBagBy(String::valueOf);
        Verify.assertSortedBagsEqual(TreeBag.newBagWith(PrimitiveTuples.pair(<(literal.(type))("1")>, Integer.valueOf(2)), PrimitiveTuples.pair(<(literal.(type))("2")>, Integer.valueOf(3)), PrimitiveTuples.pair(<(literal.(type))("3")>, Integer.valueOf(4))), bag);
    }

    @Test
    public void toSortedSet_natural_ordering()
    {
        RichIterable\<<name>ObjectPair\<Integer>\> pairs = this.newWith(<(literal.(type))("2")>, 3, <(literal.(type))("1")>, 2, <(literal.(type))("3")>, 4);
        MutableSortedSet\<<name>ObjectPair\<Integer>\> set = pairs.toSortedSet();
        Verify.assertSortedSetsEqual(TreeSortedSet.newSetWith(PrimitiveTuples.pair(<(literal.(type))("1")>, Integer.valueOf(2)), PrimitiveTuples.pair(<(literal.(type))("2")>, Integer.valueOf(3)), PrimitiveTuples.pair(<(literal.(type))("3")>, Integer.valueOf(4))), set);
    }

    @Test
    public void toSortedSet_with_comparator()
    {
        RichIterable\<<name>ObjectPair\<Integer>\> pairs = this.newWith(<(literal.(type))("2")>, 3, <(literal.(type))("1")>, 2, <(literal.(type))("3")>, 4);
        MutableSortedSet\<<name>ObjectPair\<Integer>\> set = pairs.toSortedSet(Comparators.reverseNaturalOrder());
        Verify.assertSortedSetsEqual(TreeSortedSet.newSetWith(Comparators.reverseNaturalOrder(),
                PrimitiveTuples.pair(<(literal.(type))("3")>, Integer.valueOf(4)),
                PrimitiveTuples.pair(<(literal.(type))("2")>, Integer.valueOf(3)),
                PrimitiveTuples.pair(<(literal.(type))("1")>, Integer.valueOf(2))),
                set);
    }

    @Test
    public void toSortedSetBy()
    {
        RichIterable\<<name>ObjectPair\<Integer>\> pairs = this.newWith(<(literal.(type))("2")>, 3, <(literal.(type))("1")>, 2, <(literal.(type))("3")>, 4);
        MutableSortedSet\<<name>ObjectPair\<Integer>\> set = pairs.toSortedSetBy(String::valueOf);
        Verify.assertSortedSetsEqual(TreeSortedSet.newSetWith(PrimitiveTuples.pair(<(literal.(type))("1")>, Integer.valueOf(2)), PrimitiveTuples.pair(<(literal.(type))("2")>, Integer.valueOf(3)), PrimitiveTuples.pair(<(literal.(type))("3")>, Integer.valueOf(4))), set);
    }

    @Test
    public void toSet()
    {
        RichIterable\<<name>ObjectPair\<Integer>\> pairs = this.newWith(<(literal.(type))("1")>, 2, <(literal.(type))("2")>, 3, <(literal.(type))("3")>, 4);
        MutableSet\<<name>ObjectPair\<Integer>\> set = pairs.toSet();
        Verify.assertContainsAll(set, PrimitiveTuples.pair(<(literal.(type))("1")>, Integer.valueOf(2)), PrimitiveTuples.pair(<(literal.(type))("2")>, Integer.valueOf(3)), PrimitiveTuples.pair(<(literal.(type))("3")>, Integer.valueOf(4)));
    }

    @Test
    public void toMap()
    {
        RichIterable\<<name>ObjectPair\<Integer>\> pairs = this.newWith(<(literal.(type))("1")>, 2, <(literal.(type))("2")>, 3, <(literal.(type))("3")>, 4);
        MutableMap\<String, String> map =
                pairs.toMap(String::valueOf, String::valueOf);
        assertEquals(UnifiedMap.newWithKeysValues("<(toStringLiteral.(type))("1")>:2", "<(toStringLiteral.(type))("1")>:2", "<(toStringLiteral.(type))("2")>:3", "<(toStringLiteral.(type))("2")>:3", "<(toStringLiteral.(type))("3")>:4", "<(toStringLiteral.(type))("3")>:4"), map);
    }

    @Test
    public void toSortedMap()
    {
        RichIterable\<<name>ObjectPair\<Integer>\> pairs = this.newWith(<(literal.(type))("1")>, 2, <(literal.(type))("2")>, 3, <(literal.(type))("3")>, 4);
        MutableSortedMap\<String, String> map =
                pairs.toSortedMap(String::valueOf, String::valueOf);
        assertEquals(TreeSortedMap.newMapWith("<(toStringLiteral.(type))("1")>:2", "<(toStringLiteral.(type))("1")>:2", "<(toStringLiteral.(type))("2")>:3", "<(toStringLiteral.(type))("2")>:3", "<(toStringLiteral.(type))("3")>:4", "<(toStringLiteral.(type))("3")>:4"), map);
    }

    @Test
    public void toSortedMap_with_comparator()
    {
        RichIterable\<<name>ObjectPair\<Integer>\> pairs = this.newWith(<(literal.(type))("1")>, 2, <(literal.(type))("2")>, 3, <(literal.(type))("3")>, 4);
        MutableSortedMap\<String, String> map =
                pairs.toSortedMap(Comparators.reverseNaturalOrder(), String::valueOf, String::valueOf);
        assertEquals(TreeSortedMap.newMapWith(Comparators.reverseNaturalOrder(), "<(toStringLiteral.(type))("1")>:2", "<(toStringLiteral.(type))("1")>:2", "<(toStringLiteral.(type))("2")>:3", "<(toStringLiteral.(type))("2")>:3", "<(toStringLiteral.(type))("3")>:4", "<(toStringLiteral.(type))("3")>:4"), map);
    }

    @Test
    public void toSortedMapBy()
    {
        RichIterable\<<name>ObjectPair\<Integer>\> pairs = this.newWith(<(literal.(type))("1")>, 2, <(literal.(type))("2")>, 3, <(literal.(type))("3")>, 4);
        MutableSortedMap\<String, String> map =
                pairs.toSortedMapBy(String::valueOf, String::valueOf, String::valueOf);
        assertEquals(TreeSortedMap.newMapWith(Comparators.naturalOrder(), "<(toStringLiteral.(type))("1")>:2", "<(toStringLiteral.(type))("1")>:2", "<(toStringLiteral.(type))("2")>:3", "<(toStringLiteral.(type))("2")>:3", "<(toStringLiteral.(type))("3")>:4", "<(toStringLiteral.(type))("3")>:4"), map);
    }

    @Test
    public void toBiMap()
    {
        RichIterable\<<name>ObjectPair\<Integer>\> pairs = this.newWith(<(literal.(type))("1")>, 2, <(literal.(type))("2")>, 3, <(literal.(type))("3")>, 4);
        MutableBiMap\<String, String> biMap = pairs.toBiMap(String::valueOf, String::valueOf);
        assertEquals(HashBiMap.newWithKeysValues("<(toStringLiteral.(type))("1")>:2", "<(toStringLiteral.(type))("1")>:2", "<(toStringLiteral.(type))("2")>:3", "<(toStringLiteral.(type))("2")>:3", "<(toStringLiteral.(type))("3")>:4", "<(toStringLiteral.(type))("3")>:4"), biMap);
    }

    @Test
    public void testToString()
    {
        RichIterable\<<name>ObjectPair\<Integer>\> collection = this.newWith(<(literal.(type))("1")>, 2, <(literal.(type))("2")>, 3);
        assertTrue("[<(toStringLiteral.(type))("1")>:2, <(toStringLiteral.(type))("2")>:3]".equals(collection.toString())
                || "[<(toStringLiteral.(type))("2")>:3, <(toStringLiteral.(type))("1")>:2]".equals(collection.toString()));
    }

    @Test
    public void makeString()
    {
        RichIterable\<<name>ObjectPair\<Integer>\> collection = this.newWith(<(literal.(type))("1")>, 2, <(literal.(type))("2")>, 3, <(literal.(type))("3")>, 4);
        assertEquals(collection.toString(), '[' + collection.makeString() + ']');
    }

    @Test
    public void makeStringWithSeparator()
    {
        RichIterable\<<name>ObjectPair\<Integer>\> collection = this.newWith(<(literal.(type))("1")>, 2, <(literal.(type))("2")>, 3, <(literal.(type))("3")>, 4);
        assertEquals(collection.toString(), '[' + collection.makeString(", ") + ']');
    }

    @Test
    public void makeStringWithSeparatorAndStartAndEnd()
    {
        RichIterable\<<name>ObjectPair\<Integer>\> collection = this.newWith(<(literal.(type))("1")>, 2, <(literal.(type))("2")>, 3, <(literal.(type))("3")>, 4);
        assertEquals(collection.toString(), collection.makeString("[", ", ", "]"));
    }

    @Test
    public void appendString()
    {
        RichIterable\<<name>ObjectPair\<Integer>\> collection = this.newWith(<(literal.(type))("1")>, 2, <(literal.(type))("2")>, 3, <(literal.(type))("3")>, 4);
        Appendable builder = new StringBuilder();
        collection.appendString(builder);
        assertEquals(collection.toString(), '[' + builder.toString() + ']');
    }

    @Test
    public void appendStringWithSeparator()
    {
        RichIterable\<<name>ObjectPair\<Integer>\> collection = this.newWith(<(literal.(type))("1")>, 2, <(literal.(type))("2")>, 3, <(literal.(type))("3")>, 4);
        Appendable builder = new StringBuilder();
        collection.appendString(builder, ", ");
        assertEquals(collection.toString(), '[' + builder.toString() + ']');
    }

    @Test
    public void appendStringWithSeparatorAndStartAndEnd()
    {
        RichIterable\<<name>ObjectPair\<Integer>\> collection = this.newWith(<(literal.(type))("1")>, 2, <(literal.(type))("2")>, 3, <(literal.(type))("3")>, 4);
        Appendable builder = new StringBuilder();
        collection.appendString(builder, "[", ", ", "]");
        assertEquals(collection.toString(), builder.toString());
    }

    @Test
    public void groupBy()
    {
        RichIterable\<<name>ObjectPair\<Integer>\> collection = this.newWith(<(literal.(type))("1")>, 2, <(literal.(type))("2")>, 3, <(literal.(type))("3")>, 4);
        Function\<<name>ObjectPair\<Integer>, Boolean> function = (<name>ObjectPair\<Integer> object) -> PrimitiveTuples.pair(<(literal.(type))("1")>, Integer.valueOf(2)).equals(object);

        Multimap\<Boolean, <name>ObjectPair\<Integer>\> multimap = collection.groupBy(function);
        assertEquals(3, multimap.size());
        assertTrue(multimap.containsKeyAndValue(Boolean.TRUE, PrimitiveTuples.pair(<(literal.(type))("1")>, Integer.valueOf(2))));
        assertTrue(multimap.containsKeyAndValue(Boolean.FALSE, PrimitiveTuples.pair(<(literal.(type))("2")>, Integer.valueOf(3))));
        assertTrue(multimap.containsKeyAndValue(Boolean.FALSE, PrimitiveTuples.pair(<(literal.(type))("3")>, Integer.valueOf(4))));
    }

    @Test
    public void groupByEach()
    {
        RichIterable\<<name>ObjectPair\<Integer>\> collection = this.newWith(<(literal.(type))("1")>, 2, <(literal.(type))("2")>, 3, <(literal.(type))("3")>, 4);
        Function\<<name>ObjectPair\<Integer>, MutableList\<Boolean>\> function = (<name>ObjectPair\<Integer> object) -> Lists.mutable.of(PrimitiveTuples.pair(<(literal.(type))("1")>, Integer.valueOf(2)).equals(object));

        Multimap\<Boolean, <name>ObjectPair\<Integer>\> multimap = collection.groupByEach(function);
        assertEquals(3, multimap.size());
        assertTrue(multimap.containsKeyAndValue(Boolean.TRUE, PrimitiveTuples.pair(<(literal.(type))("1")>, Integer.valueOf(2))));
        assertTrue(multimap.containsKeyAndValue(Boolean.FALSE, PrimitiveTuples.pair(<(literal.(type))("2")>, Integer.valueOf(3))));
        assertTrue(multimap.containsKeyAndValue(Boolean.FALSE, PrimitiveTuples.pair(<(literal.(type))("3")>, Integer.valueOf(4))));
    }

    @Test
    public void zip()
    {
        RichIterable\<<name>ObjectPair\<Integer>\> collection = this.newWith(<(literal.(type))("1")>, 2, <(literal.(type))("2")>, 3);
        RichIterable\<Pair\<<name>ObjectPair\<Integer>, Integer>\> result = collection.zip(Interval.oneTo(5));

        assertTrue(Bags.mutable.of(Tuples.pair(PrimitiveTuples.pair(<(literal.(type))("1")>, Integer.valueOf(2)), 1), Tuples.pair(PrimitiveTuples.pair(<(literal.(type))("2")>, Integer.valueOf(3)), 2)).equals(result.toBag())
                || Bags.mutable.of(Tuples.pair(PrimitiveTuples.pair(<(literal.(type))("2")>, Integer.valueOf(3)), 1), Tuples.pair(PrimitiveTuples.pair(<(literal.(type))("1")>, Integer.valueOf(2)), 2)).equals(result.toBag()));
    }

    @Test
    public void zipWithIndex()
    {
        RichIterable\<<name>ObjectPair\<Integer>\> collection = this.newWith(<(literal.(type))("1")>, 2, <(literal.(type))("2")>, 3);
        RichIterable\<Pair\<<name>ObjectPair\<Integer>, Integer>\> result = collection.zipWithIndex();
        assertTrue(Bags.mutable.of(Tuples.pair(PrimitiveTuples.pair(<(literal.(type))("1")>, Integer.valueOf(2)), 0), Tuples.pair(PrimitiveTuples.pair(<(literal.(type))("2")>, Integer.valueOf(3)), 1)).equals(result.toBag())
                || Bags.mutable.of(Tuples.pair(PrimitiveTuples.pair(<(literal.(type))("2")>, Integer.valueOf(3)), 0), Tuples.pair(PrimitiveTuples.pair(<(literal.(type))("1")>, Integer.valueOf(2)), 1)).equals(result.toBag()));
    }

    @Test
    public void chunk()
    {
        RichIterable\<<name>ObjectPair\<Integer>\> collection = this.newWith(<(literal.(type))("1")>, 2, <(literal.(type))("2")>, 3, <(literal.(type))("3")>, 4);
        assertEquals(Bags.immutable.of(FastList.newListWith(PrimitiveTuples.pair(<(literal.(type))("1")>, Integer.valueOf(2))),
                FastList.newListWith(PrimitiveTuples.pair(<(literal.(type))("2")>, Integer.valueOf(3))),
                FastList.newListWith(PrimitiveTuples.pair(<(literal.(type))("3")>, Integer.valueOf(4)))),
                collection.chunk(1).toBag());
    }

    @Test
    public void chunk_zero_throws()
    {
        RichIterable\<<name>ObjectPair\<Integer>\> collection = this.newWith(<(literal.(type))("1")>, 2, <(literal.(type))("2")>, 3, <(literal.(type))("3")>, 4);
        assertThrows(IllegalArgumentException.class, () -> collection.chunk(0));
    }

    @Test
    public void chunk_large_size()
    {
        RichIterable\<<name>ObjectPair\<Integer>\> collection = this.newWith(<(literal.(type))("1")>, 2, <(literal.(type))("2")>, 3, <(literal.(type))("3")>, 4);
        Verify.assertIterableSize(3, collection.chunk(10).getFirst());
    }

    @Test
    public void empty()
    {
        Verify.assertIterableEmpty(this.newWith());
        assertTrue(this.newWith().isEmpty());
        assertFalse(this.newWith().notEmpty());
    }

    @Test
    public void notEmpty()
    {
        RichIterable\<<name>ObjectPair\<Integer>\> notEmpty = this.newWith(<(literal.(type))("1")>, 2);
        Verify.assertIterableNotEmpty(notEmpty);
    }

    @Test
    public void aggregateByMutating()
    {
        Function0\<AtomicInteger> valueCreator = Functions0.zeroAtomicInteger();
        Procedure2\<AtomicInteger, <name>ObjectPair\<Integer>\> sumAggregator = (AtomicInteger aggregate, <name>ObjectPair\<Integer> value) -> aggregate.addAndGet((int) value.getOne());
        RichIterable\<<name>ObjectPair\<Integer>\> collection = this.newWith(<(literal.(type))("1")>, 2, <(literal.(type))("2")>, 3, <(literal.(type))("3")>, 4);
        MapIterable\<String, AtomicInteger> aggregation = collection.aggregateInPlaceBy(String::valueOf, valueCreator, sumAggregator);
        assertEquals(3, aggregation.get("<(toStringLiteral.(type))("3")>:4").intValue());
        assertEquals(2, aggregation.get("<(toStringLiteral.(type))("2")>:3").intValue());
        assertEquals(1, aggregation.get("<(toStringLiteral.(type))("1")>:2").intValue());
    }

    @Test
    public void aggregateByNonMutating()
    {
        Function0\<Integer> valueCreator = Functions0.value(0);
        Function2\<Integer, <name>ObjectPair\<Integer>, Integer> sumAggregator = (Integer aggregate, <name>ObjectPair\<Integer> value) -> (int) (aggregate + value.getOne());
        RichIterable\<<name>ObjectPair\<Integer>\> collection = this.newWith(<(literal.(type))("1")>, 1, <(literal.(type))("1")>, 2, <(literal.(type))("2")>, 3);
        MapIterable\<String, Integer> aggregation = collection.aggregateBy(String::valueOf, valueCreator, sumAggregator);
        assertEquals(2, aggregation.get("<(toStringLiteral.(type))("2")>:3").intValue());
        assertEquals(1, aggregation.get("<(toStringLiteral.(type))("1")>:2").intValue());
    }
}

>>
